/**
 * @author: ManhNV
 * @description config authenticate service
 * @create 2017/06/13
 */

import unless from 'express-unless';
import crypto from 'crypto';
import _ from 'lodash';
import jwt from 'jsonwebtoken';
import randomstring from 'randomstring';
import chalk from 'chalk';
import config from '../config/environment';
import { Constants } from '../common/constants';
import compose from 'composable-middleware';
import ForbiddenError from '../common/error_handler/base_error/state.error/ForbiddenError';

/**
 * @method hasRole
 * @description middleware access resource with permission
 * @summary if accessToken valid with user role = 'admin'  ==> param role no sense
 * @param role
 */
export function hasRole(role = Constants.ROLES.ADMIN) {
  // return next();
  return compose()
    .use((req, res, next) => {
      if (req.user.role === Constants.ROLES.ADMIN) {
        return next();
      }
      if (req.user.role !== role) {
        // return res.bad(new ForbiddenError('permission_denied', {message: 'User has no permission to access this resource.'}));
        return res.bad(new ForbiddenError());
      }
      return next();
    });
}

/**
 * @method hasEnv
 * @description middleware access resource with permission
 * @summary if accessToken valid with user role = 'admin'  ==> param role no sense
 * @param role
 * @param environment
 */
export function hasEnv(role = Constants.ROLES.ADMIN, environment = 'development') {
  // return next();
  return compose()
    .use((req, res, next) => {
      if (req.user.role === Constants.ROLES.ADMIN) {
        return next();
      }
      if (req.user.role !== role) {
        // return res.bad(new ForbiddenError('permission_denied', {message: 'User has no permission to access this resource.'}));
        return res.bad(new ForbiddenError());
      }
      if (environment !== 'development') {
        return res.bad('Production not using api. Permission execute development');
      }
      return next();
    });
}

/**
 * @method acceptedAllOrigin
 * @description: accept domain request
 * @returns acceptAllOrigin
 */
export function acceptedAllOrigin() {
  let acceptAllOrigin = function (req, res, next) {
    res.header("Access-Control-Allow-Origin", "*");
    res.header("Access-Control-Allow-Headers", "Authorization, Origin, X-Requested-With, Content-Type, Accept");
    res.header('Access-Control-Allow-Methods', 'PUT, DELETE');
    next();
  };

  acceptAllOrigin.unless = unless;
  return acceptAllOrigin;
}

/**
 * @method acceptedRoleAdmin
 * @description: accept request with permission administrator
 * @returns acceptPermissionAdmin
 */
export function acceptedRoleAdmin() {
  let acceptPermissionAdmin = function (req, res, next) {
    if (_.values(Constants.ROLES).slice(1, 4).indexOf(req.user.roles) !== -1) {
      return res.status(401).json({ ErrorMessage: 'Not access!' });
    }
    return next();
  };

  acceptPermissionAdmin.unless = unless;
  return acceptPermissionAdmin;
}

/**
 * @description generates random string of characters i.e salt
 * @function
 * @param {number} length - Length of the random string.
 */
export function genRandomString(length) {
  return crypto.randomBytes(Math.ceil(length / 2))
    .toString('hex') /** convert to hexadecimal format */
    .slice(0, length);
}

/**
 * @description hash password with sha512.
 * @function
 * @param {string} password - List of required fields.
 * @param {string} salt - Data to be validated.
 * @param {string} algorithm
 * @return {{salt: *, password_hash}}
 */
export function sha512(password, salt, algorithm = 'sha512') {
  const hash = crypto.createHmac(algorithm, salt);
  hash.update(password);
  return hash.digest('hex');
}

/**
 * @method signToken
 * @description returns a jwt token signed by the app secret
 * @param {object} user user-information
 */
export function signToken(user) {
  return jwt.sign(user, config.jwt_secret, {
    expiresIn: config.timeTokenExpire
  });
}

/**
 * @method genAppSecret
 * @param {string} strEncode
 */
export function genAppSecret(strEncode) {
  return randomstring.generate({
    length: 40,
    charset: strEncode
  });
}

/**
 * Token generated by concatenating username and password with `:` character within a base64 encoded string.
 *
 * @param  {String} user
 * User identifier.
 *
 * @param  {String} pass
 * Password.
 *
 * @return {String}
 * Base64 encoded authentication token.
 */
export function basicAuthGenerateToken(user, pass) {
  /**
   * Base64 encode string.
   *
   * @param  {String} string
   * String input.
   *
   * @return {String}
   * Base64 encoded string.
   */
  function base64(string) {
    const ENCODING = 'base64';
    return new Buffer(string).toString(ENCODING);
  }

  return base64([user, pass].join(':'));
}

export function mapUnlessApi(arrLink) {
  const arrLinkMap = arrLink.map(link => `/api/${config.apiVersion}${link}`);
  console.log(chalk.bgRedBright.black('Unprotected list api:'));
  console.log(arrLinkMap);
  return arrLinkMap;
}

export function mapUnlessApiUsingRegex(regex) {
  let re = new RegExp(regex.join("|"), "g"); //pattern flags: g
  console.log(chalk.bgRedBright.black('Unprotected list api by regex:'));
  console.log(re);
  return re;
}

export function mapAdminApi(data) {
  console.log(chalk.bgRedBright.black('Admin list api:'));
  return data.map(item => {
    if (typeof item === 'string') {
      item = urlPrefix(item);
      item = `/api/${config.apiVersion}${item}`;
    } else if (typeof item === "object") {
      if (item.regex === true) {
        item.url = new RegExp(item.url);
      } else {
        item.url = urlPrefix(item.url);
        item.url = `/api/${config.apiVersion}${item.url}`;
      }
      console.log(`${item.url},`);
    }
    return item;
  });
}

function urlPrefix(url) {
  if (url[0] !== '/') url = `/${url}`;
  return url;
}

export function getJWTPayload(user) {
  return {
    _id: user._id,
    role: user.role,
    active: user.active,
    receiveNotify: user.receiveNotify,
    avatar: user.avatar || '',
    pathImage: `${config.imageStore.host}:${config.node_env === 'local' ? `:${config.port}` : ''}${config.imageStore.baseDir}/`,
    stripeKey: user.stripeKey,
    email: user.email,
    customerId:user.customerId

  };
}